<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Николай</title>
  <link rel="stylesheet" href="css/static.css" />
</head>
<body class="ui-mobile-viewport ui-overlay-a">
  <div id="content"></div>
  <a href='index.html'>Домой</a>
<div class=WordSection1>
<p>
<span>
  <b>Стандарты разработки Java для outsource проектов</b>
Технологические требования к приложению:

Java 11
Spring Boot 2.2.+ (Core, Data, Messaging), Lombock, Mapstruct, Apache Commons.
Для тестирования Spring Boot Test, JUnit 5, Mockito, TestContainers, WireMock.
Логирование через slf4j и logback, возможность настройки по отправке логов в stdout, TCP
socket.
Для интеграции с REST сервисами необходимо использовать Feign/RestTemplate/WebClient.
Для интеграции с SOAP сервисами необходимо использовать Apache CXF.
Мониторинг через Spring Boot Actuator+Micrometer для последующий отправки в
Prometheus.
Система сборки Gradle.
Для параметризации приложений использовать Spring Boot Config Server + Environment
Variables.
Нетехнологические требования к приложению:

Использование микросервисной архитектуры, там где это уместо.
Использование RESTful API для реализации синхронных взаимодействий.
Обязательное наличие документации на все "исполняемые" методы (отдельные методы
API, listener очередей, scheduled методы)
Обязательное покрытие тестами всех "исполняемых" методов (отдельные методы API,
listener очередей, scheduled методы).
Необходимо логировать все запросы и ответы от клиентов к API приложения и все запросы
и ответы от приложения к внешним сервисам.
Требования по инфраструктуре:

Для хранения данных: Oracle (Postgresql), MongoDB, Elasticsearch.
Для очередей: Kafka.
Для кеширования: Hazelcast или Caffeine.
В качестве конечного артефакта использовать docker контейнеры. Для развертывания
всего проекта необходимо предоставить docker-compose файл.

<b>Статический анализ кода Java</b>
Стат. анализ в Java сейчас реализуется плагином
http://git.moscow.alfaintra.net/projects/TEC/repos/application-configure-gradle-plugins/, там
подключены следующие анализаторы:

CodestyleAutoformat - http://git.moscow.alfaintra.net/projects/TEC/repos/codestyle-autoformat-
gradle-plugin/
SonarQube - https://plugins.gradle.org/plugin/org.sonarqube
Quality - http://git.moscow.alfaintra.net/projects/AMML/repos/quality-gradle-plugin/, включает в
себя:
- CheckStyle - https://checkstyle.sourceforge.io/
- Pmd - https://pmd.github.io/
- SpotBugs - https://spotbugs.github.io/
- Codenarc - http://codenarc.sourceforge.net/

<b>Code-review Java</b>
Общие соглашения:

Все изменения в код вливаются через PR
Мы стремимся делать PR минимального размера

На сервисы, которые переиспользуются в других проектах или являются общими,
назначены дефолтные ревьюеры, их аппрув обязателен

При мерже мы удаляем ветки в гите

Используем инструменты Статический анализ кода Java
НИБ/АБМ:

<b>Требования к сервисам НИБ/АБМ</b>
Правила оформления pull-request'ов и проведения code review
Pull-request и процесс code review - два неразрывно связанных друг с другом понятия. В
этой статье я постараюсь ответить на несколько вопросов:

какие основные цели проведения код-ревью: с позиции разработчика и с позиции ревьюера.
как оформить свой pull-request, так чтобы процесс code review был максимально
продуктивен для обеих сторон.
как проводить code review, чтобы у разработчика не сложилось впечатление, что code
review - это неизбежное зло.
Цели pull-request и code review
Давайте сначала попробуем понять для чего нам нужен этот процесс:

Получение обратной связи. Обратить внимание на ошибки, которые были не замечены в
процессе разработки, дать идеи для рефакторинга.
Улучшение понимания проекта. Отточить свои навыки в чтении чужого кода и понять
бизнес-процессы другого проекта, что в свою очередь позволит меньше тратить времени на
последующие code review.
Снижение рисков ошибок в проекте.
Поддержка согласованности кода проекта. Отследить выполнение стандартов проекта,
требования по безопасности (все ли пароли зашифрованы и т. п.).
Развитие инженерной культуры. Научиться эффективно проводить code review.
Обучение и передача опыта. Путём взаимодействия через pull-request'ы происходит
обучение начинающих разработчиков более опытными. Исправляя свои ошибки, мы
учимся.
Правила создания и оформления pull-request
Всё начинается с правильно оформленного pull-request. Давайте рассмотрим несколько
рекомендаций, которые упростят ревьюерам процесс проведения code review, а значит и
ускорят его.

Атомарность pull-request
Pull-request должен делать только то, что непосредственно описано в задаче или
затрагивается во время реализации. Все изменения, которые попадают в pull-request
должны относиться строго к поставленной задаче. Если в процессе написания кода вы
замечаете, что неплохо было бы отрефакторить часть кода или обнаруживаете баг или
потенциально опасный код, то такие изменения не стоит включать в данный pull-request.
Заведите задачу в jira и создайте отдельный pull-request.

Pull-request не должен превышать 300-400 строчек кода. Большие pull-request долго и
тяжело просматривать. Как правило, такие pull-request просматриваются по диагонали и не
достигают поставленных выше целей. Практика показывает, что быстрее и качественнее
проходит code review трёх pull-request по 400 строк кода, чем одного pull-request на 1200
строк кода, при условии, что review выполняется тщательно в обоих случаях. Если вам
предстоит большая задача, то помимо основной ветки branch от master, создайте несколько
pull-request'ов в саму ветку branch.

Обязательная проверка кода перед тем, как создать pull-request
Просматривайте git diff перед commit. Перед тем, как закоммитить изменения обязательно
просматривайте git diff. Стоит проверить не оставили ли вы где-либо debug-строки, TODO-
комментарии, соответствует ли ваш код правилам оформления (комментарии, пробелы и
пр. - этот процесс лучше автоматизировать, но у нас этого пока нет). Задайте себе вопрос
очевиднали логика, которую вы описали, может требуется дополнительный комментарий.

Запустите тесты и убедитесь, что они проходят. Обязательно проверяйте проходят ли все
тесты. Часто бывает так, что мы отправляем код на review, не проверив работоспособность
тестов. В итоге ревьюер видит поломавшийся build, откладывает ревью и ждёт
исправления, что порой сильно замедляет процесс.

Название должно быть кратким и точным
В Bitbucket по-умолчанию в поле Title подставляется название ветки, которую вы хотите
слить. Так как поле Title - это единственная информация, которая отображается в кратком
списке pull-request'ов, то именно, исходя из краткого названия вашего pull-request, ревьюеры
решают будут ли они его смотреть и когда.

Название должно быть кратким, но достаточно выразительным, чтобы ревьюер мог понять,
что ему ожидать. Рассмотрим в качестве примера pull-request, реализующий новое бизнес-
требование по вычислению налога для нерезидентов РФ. Название Изменение правила
вычисления налога для нерезидентов РФ точное. Изменение правила вычисления налога
для нерезидентов РФ, согласно указу ЦБ от 20.02.2020 ещё точнее, с указанием контекста.
Однако, названия для pull-request по типу: Добавление новых параметров для вычисления
налога или Изменение логики вычисления налогов слишком общие и не подходят для pull-
request. На другой стороне спектра названия, перегруженные конкретикой, например
Изменение в классе TaxInternals и CalculateEffectiveRate, согласно изменениям в указ ЦБ №
20444 от 20.02.2020. Понимание, что такое слишком много деталей или наоборот слишком
мало, зависит от того, на кого рассчитан этот pull-request, но всё же в названиях следует
придерживаться золотой середины.

Описание должно отвечать на вопрос "зачем?"
По-умолчанию в Bitbucket поле Description заполняется логом git-коммитов, вошедших в pull-
request. Эта информация не несёт в себе никакой ценности для ревьюеров и лучше
заполнить Description следующими данными:

Дать ссылку на задачу в Jira. При этом сама задача в Jira должна быть правильно
оформлена и давать представления о том, что послужило поводом для внесения
изменений.

Опишите выбранный вами способ реализации. Кратко укажите детали реализации: какие
шаблоны проектирования вы использовали, какие в коде есть сложные места, что не
удалось сделать, как хотелось изначально и почему. Если в процессе выполнения задачи
был выполнен рефакторинг, то опишите обоснование и цели рефакторинга.

Правила проведения code review
Цели code review
дать обратную связь (в том числе и положительную)
помочь сделать код понятней и проще
помочь избежать ошибок
Беремся за code review, как можно раньше. Если нет возможности взяться за ревью прямо
сейчас, поставьте автора в известность, когда вы сможете посмотреть его pull-request. В
идеале один раунд pull-request не должен занимать более двух часов.

Многораундовость
Сложные pull-request'ы разбивай на несколько раундов code review. Не нужно пытаться
провести review большого pull-request за один раз, лучше поделить его на несколько
раундов. В первом раунде стоит рассмотреть архитектурные вопросы, во втором детали
реализации, в третьем стили кодирования. Раунды должны выстраиваться по принципу от
общего к частному или от высокоуровневых вопросов к низкоуровневым.

Если pull-request содержит не связанные друг с другом части, попроси разделить его на
несколько pull-request'ов.

Количество раундов ревью должно в идеале не превышать трёх. Большое количество
раундов ревью будет затягивать процесс принятия pull-request.

Процесс code review
Вначале читаем описание к pull-request, знакомимся со всеми приложенными документами,
комментариями. Переходим и смотрим связанную задачу в Jira. Думаем над тем, как бы эту
задачу реализовали вы.

Далее проходим по трём шагам. Если все три шага удаётся сделать за один раунд code
review отлично, если нет, то откладываем те шаги, которые вызывают затруднения на
следующий раунд.

1. Проверка выполнения задачи, общая архитектура
Проверяем, что код решает поставленную задачу в полном объёме. Возможно есть какие-то
corner cases, которые не рассмотрел автор. Смотрим на тесты, контроллеры. Если что-то
непонятно, то лучше запустить код, прогнать тесты на своей машине.

Смотрим на принятые архитектурные решения. Не является ли это решение слишком
сложным, есть ли более простые решения. Обратите внимание автора на это, приведите
пример реализации или дайте ссылку на неё.

Проверяем взаимодействие отдельных частей приложения, микросервисов. Является ли
данное взаимодействие оптимальным? Если есть реализации, которые уже реализованы в
проекте или других микросервисах, стоит указать автору на это.

Здесь же смотрим на соответствие документации коду, если какой-то момент не
задокументирован, стоит упомянуть об этом.

2. Проверка реализации
Смотрим внимательнее на реализацию. Использует ли автор общие для проектов стэка
библиотеки. Ищем код, который можно написать проще. Смотрим за тем, чтобы логика
располагалась в предназначенных для неё местах (например, работа с базой данных
располагалась внутри репозитория).

Если какая-то ошибка повторяется в коде больше одного раза, не пишем кучу однотипных
комментариев, создаем общий комментарий вне кода и указываем ссылку на него из мест,
где присутствует ошибка

3. Проверка стиля
Просматриваем код построчно на выявление неудачных названий, стилистических ошибок.

Данная часть не должна занимать много времени и должна быть по максимуму
автоматизирована.

Так как читаемость кода - дело субъективное не переусердствуйте на данном этапе.

В IntelliJ Idea можно установить SonarQube plugin и настроить его на http://corpint3/gulag.
Тогда уже в процессе написания кода можно будет запускать Analyze -> Inspect code... и
получать отчёты об ошибках, найденных sonar.

Несколько советов
Выносите серьёзные ошибки, требующие исправления в виде task. Если вы заметили
серьёзную ошибку, создайте task в комментарии.

Используйте Needs Work. Если нашли ошибки, сообщите об этом автору, при помощи
кнопки Needs Work, не думайте, что автор с наскоку увидит все ваши комментарии.

Если ошибки не существенны или основные ошибки поправлены, не задерживайте pull-
request. Не стоит держать pull-request до тех пор, пока автор не поправит все обнаруженные
ошибки. Доверяйте коллегам, они в состоянии внести минорные изменения самостоятельно.

Обозначения в комментариях code review
WIP (Work in progress). Если вы добавляете коммиты в pull-request, но при этом работа над
ним ещё не закончена, стоит каким-то образом известить об этом ревьюеров. Один из
способов сделать это - указать перед названием pull-request'а тег [WIP].

nit (nitpicking). Любые несущественные замечания в комментариях к pull-request стоит
отмечать при помощи тега nit, предшествующего комментарию.

Настройки Merge Checks
Исходя из всего вышесказанного, вы можете настроить Bitbucket Merge Checks, так чтобы
они не пропускали плохой код в production.

All reviewers approve - Disabled. Не имеет никакого смысла ждать принятия pull-request всеми
ревьюерами, можно и не дождаться.

Minimum approvals - Enabled. Number of approvals >= 1. Задаём минимальное число принятий
pull-request больше или равно одному. Это не пропустит непросмотренные pull-request'ы.

Minimum successful builds - Enabled. Number of builds >= 1. Проект должен успешно
собираться, будет очень здорово, если за этим будет следить Bitbucket.

No 'Needs work' status - Enabled. Если мы договариваемся, в случае критичных ошибок,
выставлять статус 'Needs work', то такие pull-request'ы не должны быть смерджены.

No incomplete tasks - Enabled. Та же самая история с tasks. Если мы заводим tasks на
критичные замечания, то BitBucket будет препятствовать слиянию таких pull-request’ов.

Соглашения по построению API
Порты для распределённого кэша

Название проекта	порты	Mode
corp-list	30001-30020	TCP

Переиспользование сервисов.
На текущий момент есть деление на корневые и проектные сервисы - корневые
используются в нескольких проектах, проектные используются только в соответствующим
им проектам.

По факту корневых сервисов оказалось слишком много, а проектных сервисов оказалось
слишком мало, поэтому предлагается уходить в сторону общего списка сервисов,
переиспользумых всеми желающими.

Концепция корневых переиспользуемых сервисов:

один исходник
с одной основной веткой
без форков.
Отдельных постоянных веток для отдельных проектов нет - только мастер, в который
вливаются доработки. Из этого мастера собирается образ (версионированный, на одну
версию всегда один образ, для всех проектов общий).

Если команде нужен этот сервис для проекта, то в скриптах проекта раскатывается этот
образ со своими настройками, отдельным независимым контейнером. Таким образом все,
кто используют данный сервис, катают у себя отдельный экземпляр.

Когда кто-то обновляет мастер - обновляется (собирает и раскатывает для себя) только
тот проект, которому это было нужно (который делал пул реквест в мастер), остальные
проекты живут на старой версии.

Когда остальным проектам надо подтянуться или доработать сервис для себя -
подтягивают себе все доработки (раскатывают у себя образ крайней версии).

Пример корневого сервиса
Исходник profiles-api.

Развернутые сервисы:

http://corpmesosint1/marathon/ui/#/apps/%2Fcorp-list%2Fmiddle%2Fprofiles-api
http://corpmesosint1/marathon/ui/#/apps/%2Fcorp-dash%2Fmiddle%2Fprofiles-api
http://corpmesosint1/marathon/ui/#/apps/%2Fcorp-depo%2Fmiddle%2Fprofiles-api
Для разделения настроек и самих сервисов используется такое свойство как
PROJECT_KEY:

настраивается в скриптах раскатки,
используется как часть наименования сервиса в марафоне,
используется как префикс/папка настроек в консуле или конфиг-сервере,
используется как префикс пути, по которому сервис будет доступен через балансировщик
(nginx/haproxy).
Это позволяет настраивать и использовать каждый экземпяр этого сервиса по
отдельности.

Пример PROJECT_KEY - http://git/projects/CORP-DEPO/repos/corp-depo-
ansible/browse/group_vars/all/main.yml.

Доменная модель
На текущий момент сервисы проектируются таким образом, чтобы предоставить набор
неких атомарных операций, которые позволят собрать любую необходимую сложную
операцию как композицию этих простых операций.

По факту, это CRUD доступ к некоторым ресурсам/предметным сущностям (счета, карты,
компании и т.д.).

Кроме соглашения на CRUD по ресурсу, есть также ряд некоторых соглашений:

Сервис, предоставляющий доступ к ресурсу/предметной сущности, должен предоставлять
не больше одного метода для получения информации об одном экземпляре данного
ресурса и не больше одного метода для получения списка экземпляров ресурса. То есть не
должно быть метода получения отдельного атрибута сущности. Для примера:
не должно быть отдельного метода получения данных о базовой информации по счету
не должно быть отдельного метода получения информации кто владелец счета
не должно быть отдельного метода получения баланса счета
не должно быть отдельного метода получения сведений что за банк контролирует этот счет
должен быть один метод для получения ВСЕЙ доступной информации). Для облегчения
работы сервиса в качестве параметра вызова он может принимать Projection - некий обьект,
рассказывающий, какие именно поля нужно вернуть.
Сервис, работающий с определенной предметной сущностью, не должен возвращать
несколько предметных сущностей, даже если они связаны. То есть если нужны данные
счета и данные его владельца, то сервис по счетам должен вернуть только данные счета и
не должен возвращать данные владельца. В данных счета можно указать привязку к
владельцу( в виде id ), чтобы потребитель сервиса мог сходить к соответсвующему
сервису по выданному id.
Тестирование
Тесты должны быть документацией на сервис

Если я хочу узнать, как мне сервис ответит на мой запрос (к примеру, в каком формате
вернет счета, если я кину код клиента), я иду в тесты и смотрю на тест этой истории (тест
истории "По коду клиента вернуть список счетов").

Этот же подход позволит проще генеририть более читабельную документацию, потому что
истории будут user friendly - я хочу проверить права на создание платежки, поэтому я кидаю
запрос с правом CREATE_PAYMENT и только CREATE_PAYMENT, получаю
соответствующий ответ, в зависимости от условий.

Если вместо этого предлагается идти в историю вида "should call services with correct
parameters", которых обычно немало и которая по названию никак не мапится с задачей
проверить CREATE_PAYMENT, и искать в этой истории, кидается ли код
CREATE_PAYMENT, и какой же из ответов ему соответствует, то это вызовет путаницу и
трату времени на поиск и понимание, а также сгенерирует неудобную документацию.

Конечная цель этих тестов - гарантировать что сервис выполняет целевой набор бизнес-
историй.

BDD тесты должны описывать свое поведение с точки зрения потребителя, который о
внутренностях сервиса ничего не знает, он не идет с вопросом "А какие проверки будут
фейлиться, если у меня нет доступа к счетам?". Потребитель идет с вопросом "В каких
случаях у меня будет фейлиться проверка на CREATE_PAYMENT?".

Проверить CREATE_PAYMENT и вернуть OK, если есть доступ и не заблочен юзер - это
нормальная бизнес-история, которая несет пользу.

Как антипример, "should call services with correct parameters" - это вобще не бизнес-история,
в которой мы не гарантируем ничего. Ну вызвали мы сервис с правильным параметрами,
ответ-то сервиса правильный с точки зрения бизнеса? нужный ли? если нужный, то для
чего?

Как пример, есть два вызова получения списка депозитных предложений, которые
отличаются только кодом в запросе, и это тем не менее две нормальные истории:

should return deposits list
should return nso list
Достаточно крутой тулинг для тестов как доки прикрутили АМ -
NonFinancialControllerNewSpec.groovy.

Про этот тулинг и почему документировать надо тестами - запись вебинара от чувака,
который лидит разработку половины того, что мы используем -
https://www.youtube.com/watch?v=knH5ihPNiUs.

Подробный и детальный туториал - https://www.tothepoint.company/blog/spring-rest-doc/.

Правило 80/20

20% времени DevTeam остается на:
технические задачи от ЦК
анализ и исправление инцидентов на production, которые не относятся к конкретной команде
исправление критичных дефектов, которые не относятся к конкретной команде
другие непредвиденные отвлечения от разработки новых задач
все это в сумме должно укладываться в 20%.
При планировании продуктового спринта, в него добавляются задачи ЦК самим
разработчиком, либо командой. Задачи от ЦК с целью обеспечения их учета и
прозрачности добавляются на Jira доску команды.
Подход привлечения сотрудника DevTeam к техническим задачам остается гибким,
исключительные случае решаем индивидуально. От внедрения практики обязательного
еженедельного отвлечения сотрудников из команды отказываемся.
Исправление критичных дефектов, которые не относятся к конкретной команде - если
время исправления дефекта укладывается в 1 день. Если исправление дефекта требует
больше 1 дняm, то кейс выносится на обсуждение с бизнесом.
Договоренности для НИБ - 80/20.

Презентация, правда от ЦК Мобильной разработки, но ее можно использовать для
демонстрации эффекта бизнесу.


Общие правила код-ревью для проектов java-cucumber

Процесс код-ревью
Если в команде автоматизации тестирования на проекте более 1 человека, необходимо
организовать процесс код-ревью.
В зависимости от кол-ва людей можно выбрать следующие схемы:

Сотрудники проверяют друг друга. В ревью участвует 1 человек (подходит, если на проекте
2-3 автотестировщика).
Сотрудники проверяют друг друга + второе ревью проводит тим лид команды. В ревью
участвует 2 человека (подходит, если на проекте 3 и более автотестировщиков).
2 сотрудника делают ревью. После исправления всех замечаний тим лид проводит
окончательное ревью. В ревью участвует 3 человека (подходит, если на проекте 4 и более
автотестировщиков).
Правила для разработчиков
Правила написания автотестов и оформление feature-файлов
Делать сценарии независимыми друг от друга в рамках одного feature-файла.
Чтобы исключить ситуацию, когда падает один сценарий и из-за этого все последующие.
Разбивать тесты с большим кол-вом сценариев на несколько feature-файлов.
По возможности сделать так, чтобы одна фича выполнялась не более 10 минут (число 10 -
условное, здесь нужно отталкиваться от проекта).
Грамотно использовать функционал cucumber-а: Предыстория, Сценарий, Структура
сценария.
Например, если все сценарии в фиче имеют общие начальные действия, то логично эти
действия вынести в Предысторию.
Правила оформления пулл реквестов и работа с гитом
Пулл реквест создается только после того, как полностью закончили разработку и
проверили на работоспособность.
После создания пулл реквеста необходимо зайти в него и убедиться, что не добавили
случайно что-нибудь лишнее.
Коммиты называть логично, не просто наборомом символов.
Плохие примеры: "12421", "fix", "test". Хорошие примеры: "Написан новый тест 10.01",
"Пофиксил метод check_element", "Добавил нового клиента в тест ХХ.ХХ".
После того как проверяющий оставил все комментарии к пулл реквесту, не добавлять
новых изменений(info)
Разрешаются только изменения в рамках исправления замечаний по комментариям.
Лучше делать больше "небольших" пулл реквестов, чем один с большим количеством
новых доработок.
Чем меньше объем изменений - тем качественне и быстрее будет происходить процесс
ревью.
Для каждого модуля создать свою ветку и работать в ней. После чего делать пулл реквест
в master.
Правила написания кода
Избегать использование sleep. Использовать только для отладки.
Придерживаться общепринятых стандартов стиля написания кода на языке Java.
Оставлять как можно больше комментариев в коде.
Не всё, что очевидно для вас сейчас, будет очевидно через месяц/полгода/год. И так же
это может быть не очевидно для ваших коллег.
XML, JSON, большие SQL-запросы и т. д.  выносить из кода в отдельные файлы.
По возможности хранить тестовые данные и настройки отдельно от кода - выносить в
конфигурационные файлы.
По возможности создавать в автотестах тестовые данные.
Логировать как можно больше информации в коде, чтобы в случае падения теста получать
больше информации.
Например, выводить информацию в виде "Ожидаемый и фактический результат", а не
просто сообщением "Проверка провалилась".
Проверить, что у цикла есть запасное условие выхода.
Например, есть цикл, который выполняет клик по кнопке, пока она не пропадет с экранной
формы. Может возникнуть ситуация, когда после клика по кнопке, она не пропадет (из-за
дефекта или новой доработки).
В цикл нужно добавить дополнительное условие выхода - например, завершить цикл после
5 кликов.
Правила для проверяющего
Максимально ответственно подходить к процессу ревью. Проводить ревью "на свежую
голову".
На время ревью отложить другие задачи, чтобы не отвелкаться.
Проверить, что все изменения в пулл реквесте придерживаются общих правил (см. выше) и
правил написания на проекте.
Проверить, что разработчик придерживается стиля написания ЯП (Java) - название
переменных и классов, отступы и т.д.
Проверить, что в не самых очевидных местах в коде разработчик оставил комментарии.
Проверить соответствие шагов тест-кейса и автотеста. Убедиться, что все действия и
ожидаемые результаты присутствуют в автотесте.
Важно обратить внимание - не всегда действия находятся на поверхности (в фиче).
Например шаг "Проверили наличие всех полей на странице" требует погрузиться в код для
сверки наличия требуемых полей в тест-кейсе и в АТ.
Проверить, что к ПР приложен результат прогона автотестов локально (в виде скриншота
или ссылки на отчет в ReportPortal).


Изменения, вносимые в проект, желательно покрыть unit-тестами.

В первую очередь стоит обратить внимание на:

тесты для контрактов - протестировать формат ответа контроллеров,
результат работы мапперов для использующихся внутри приложения сущностей.


Менять существующие тестовые данные можно только в случае изменения кода, для
тестирования которого они предназначены.

Тестовые объекты желательно не собирать руками используя new(), лучше использовать
ObjectMapper и XmlMapper, скармливая им .json и .xml файлы с необходимыми данными, в
идеале с реальными примерами, взятыми из логов работы системы.



Тесты для контроллеров
Для тестирования контроллера можно использовать аннотацию @WebMvcTest, она
позволит сконфигурировать необходимый объект MockMvc и поднимет в Spring контексте
только бины, необходимые для работы web слоя.

В тесте НЕОБХОДИМО проверить ответ, полученный от контроллера. Это можно сделать с
помощью выражения .andExpect(content().json(response)), где response - это String,
cодержащий желаемый ответ в необходимом формате.

Такой ответ можно подгрузить любым способом из файла, содержащегося в тестовых
ресурсах.



Пример
String response = getFile(myCoolResponse.json);


mockMvc.perform(get("/deposits")
        .contentType(APPLICATION_JSON_VALUE)
        .param("clientId", "ASSR52"))
        .andExpect(content().json(response)) // проверяем ответ!
        .andExpect(status().isOk());


Тесты для мапперов
В тестах для мапперов можно обойтись без Spring контекста, достаточно обычного junit.

Следует проверять результат фактической работы маппера с заданным желаемым
объектом.

Тесты микросервиса
Проверить поведение всех компонентов приложения в связке можно благодаря аннотации
@SpringBootTest. Таким образом мы можем проверить поведение приложения от момента
запроса на контроллер до момента получения ответа не мокая поведение бинов
приложения.

Для этого нам необходимо создать моки всех использующихся в процессе внешних
вызовов, использую wiremock. Для тестирования процессов, требующих подключения к
mongodb исполользуется embedded mongodb, также допустимо использование тест
контейнеров (?).

В случае если мы не хотим поднятия в контексте бинов, не задействованых фактически в
наших тестах, можно задать для аннотации @SpringBootTest конфигурацию, настроенную
на ленивое сканирование бинов из корневого пакета, например:

Пример
@SpringBootTest(classes = LazyTestConfig.class)

@Configuration
@ComponentScan(lazyInit = true, basePackages = "ru.alfabank.ufr.your.root.package")
public class LazyTestConfig {
}

Java style guide.
Введение.
Приведенные здесь рекомендации предназначены для улучшения читабельности кода и
обеспечения его единообразия. Однако, иногда рекомендации из руководства не
применимы. В случае сомнений, руководствуйтесь здравым смыслом. Посмотрите на
примеры кода и выберите то, что выглядит лучше.

Рекомендации сгруппированы по темам, и каждая рекомендация пронумерована, чтобы на
нее было проще ссылаться во время ревью.

Шаблон рекомендации следующий:

n. Краткое описание рекомендации
//Пример кода, если необходимо
Мотивация, пояснения или какая-либо дополнительная информация

Содержание
Общие рекомендации.
Именование
Импорты
Выражения
Отступы
Best Practice.
Частые замечания на PR
Checkstyle
1. Общие рекомендации.
1.1. Допускается любое нарушение руководства, если оно улучшает читаемость.
Основная цель рекомендации - улучшить читаемость, понимание и общее качество кода.

2 Именование.
2.1 Избегайте специальных символов при именовании пакетов
Имена пакетов должны быть в нижнем регистре без подчеркивания или других
специальных символов.

2.2 Не используйте множественное число при именовании пакетов
Не используйте множественное число. Следуйте соглашению стандартного API. java.util not
java.utils

2.3 Имена классов должны быть существительными.
class Car {} // PREFER
class Running {} // AVOID
2.4 Имена интерфейсов должны быть существительными или прилагательными с
окончанием able и не должны начинаться с I
interface Runnable {} // PREFER
interface IEnumerable {} // AVOID. Привет шарпистам
2.5 В именах классов, переменных и интерфейсов не должно быть нескольких заглавных
букв подряд.
class XmlParser {} // PREFER
class XMLParser {} // AVOID

class IOStream {} // PREFER
class IoStream {} // AVOID
Используя аббревиатуры в наименовании руководствуйтесь следующими правилами*
Аббревиатура входит в наименование в верхнем регистре, если она состоит из двух слов
Аббревиатура входит в наименование только с первой буквой в верхнем регистре, если она
состоит из трех и более слов
2.6 Имена методов должны быть глаголами или описывать действие
public String getName() {} // PREFER
public String name() {} // AVOID

public void expand() {} // PREFER
public boolean expanding() {} // AVOID
2.7 Имена переменных должны быть в CamelCase и начинаться с нижнего регистра
int currentValue; // PREFER
int PreviousValue; // AVOID
2.8 Имена констант должны быть в верхнем регистре, разделяться c помощью _ и быть
static final
public static final BUFFER_SIZE = 1024; // PREFER
public final ARRAY_SIZE = 10; // AVOID
3. Импорты.
3.1 Не используйте неявный импорт
import some.java.package.ParticularClass; // PREFER
import some.java.package.*; // AVOID
Есть исключение для пакета java.util

import java.util.*;
Чтобы улучшить читаемость, неявный импорт следует заменить явным. Настройка импорта
в ide

3.2 Не оставляйте неиспользуемых импортов в коде.
4. Выражения.
4.1 Размерность логического выражения не должна превышать 3
boolean good_exp = (!a && b) | (a || !b) ^ a; // PREFER

boolean bad_exp = (a && b) && c && (c || b); // AVOID 3(&&) + 1(||) = 4
Слишком много условий приводит к тому, что код трудно читать, отлаживать и
поддерживать.

4.2 Избегайте объявлений массивов в стиле С
int[] nums; // PREFER
String strs[]; // AVOID
4.3 Модификаторы доступа должны следовать определенному порядку.
1. public
2. protected
3. private
4. static
5. final
6. transient
7. volatile
8. synchronized
4.4 Не следует указывать модификаторы, если они неявны
Например, методы интерфейса не следует объявлять public или abstract, а вложенные
перечисления и интерфейсы не следует объявлять static.

4.5 Используйте ссылку на метод, вместо лямбда-функции, где это имеет смысл
filter(someStrings::contains); // PREFER
filter(s -> someStrings.contains(s)); // AVOID
4.6 Инкапсулируйте логику больших лямбда-функций в методы
4.7 Используйте guard expression на входе в метод, вместо вложенности условий
public void someMethod() { // PREFER
    if (!condition) {
        throw e;
    }
    doSomething();
}

public void someMethod() { // AVOID
    if (condition) {
        doSomething();
    } else {
        throw e;
    }
}
5. Отступы.
5.1 Размер строки не должен превышать 140 символов включая отступы
5.2 Разбивайте выражения которые не влезают в 140 символов
Когда выражение не умещается в 140 символов, разбейте ее основываясь на следующих
принципах

Разделяйте выражение после запятой
Разделяйте выражение перед операторами
Сопоставьте новую строку с началом выражения на том же уровне на предыдущей строке.
5.3 Не используйте горизонтальное выравнивание переменных
public class Entity {
    public String name;
    public int age; // PREFER
}

public class Entity {
    public String name;
    public int     age; // AVOID
}
6. Best Practice.
6.1 Указывать аннотации NotNull, Nullable для библиотек
Сейчас у нас все больше распространяется Kotlin, поэтому все чаще код на нем вызывает
код библиотек, что еще написаны на Java. Чтобы не использзовать вещи типа !! для того,
чтобы избежать проблем с совместимостью, надо public static методы, интерфейс-методы,
поля DTO библиотек обозначать аннотациями, которые подскажут Kotlin как обработать
тип. Подробнее про это можно почитать в документации Kotlin.

6.2 Используйте интерфейсы с умом
Интерфейсы отделяют функциональность от реализации, что позволяет использовать
несколько реализаций не меняя сигнатуру потребителя. Так же интерфейсы - это отличный
способ изолировать реализацию, предоставляя интерфейс для взаимодействия.

Используйте интерфейсы когда

Планируется несколько реализаций схожих по смыслу сервисов
Необходимо отделить интерфейсы друг от друга для того, чтоб код был более прозрачным
(Interface Segregation principle)
Необходимо явно указать что может объект. Примерами таких интерфейсов являются
Clonable и Comparable
6.3 Избегайте использования Utility классов
Utility классы зачастую идут в разрез с принципами SOLID, а именно с Single Responsibility и
Open-Closed Principle.
Если вы все таки решились вынести какую-то логику в Utility класс, задумайтесь, возможно,
она может принадлежать уже существующему классу.

6.4 Инкапсулируйте повторяющиеся последовательности преобразования или участки кода
в методы
// PREFER

Flux<OtherEntity> filterAndConvert(Flux<Entity> entities) {
   return entities.filter(Utils::predicate)
          .map(Converter::convertToOtherEntity)
}

someEntityFlux
   .flatMap(/* converting */)
   .transform(this::filterAndConvert)

otherEntityFlux
    .map(/* do something */)
    .transform(this::filterAndConvert)

//------------------------------------------------------------

// AVOID
someEntityFlux
   .flatMap(/* converting */)
   .filter(Utils::predicate)
   .map(Converter::convertToOtherEntity)

otherEntityFlux
   .map(/* do something */)
   .filter(Utils::predicate)
   .map(Converter::convertToOtherEntity)
Метод transform позволяет применять инкапсулированные последовательности
преобразований.

6.5 Не забывайте про принцип YAGNI
Не стоит реализовывать функционал, который сейчас не нужен

7. Частые замечания на PR.
7.1 Валидация полей
7.1.1 Используйте @NotBlank для валидации текстовых полей

Аннотация @NotBlank применяется только для текстовых полей и проверяет, что свойство
не является null или пустой строкой

7.1.2 Используйте @NotEmpty для валидации коллекций

Аннотация @NotEmpty проверяет, что поле не является null или пустым

7.2 Не используйте блокирующие вызовы в асинхронном коде
Mono blockingWrapper = Mono.fromCallable(() -> {
    return /* make a remote synchronous call */
});
blockingWrapper = blockingWrapper.subscribeOn(Schedulers.boundedElastic());
Старайтесь избегать блокирующих вызовов в асинхронном коде, однако если не удается
избежать таких вызовов - используйте обертку указанную выше. Подробнее тут

7.3 Старайтесь избегать использования Mono#zip вместе с map
Mono.zip(fistInvocation, secondInvocation, ZipMerger::merge) // PREFER
Mono.zip(fistInvocation, secondInvocation).map(ZipMerger::merge) // AVOID
7.4 Прежде чем создавать свой Feign клиент, проверьте его наличие в репозитории client-
gateway-starter
Если его там нет, то подумайте/спросите, возможно, его стоит создать там, а не в своей
апишке

7.5 Не использовать контейнеры Tuple, Pair & etc в контракте
Не использовать контейнеры, что не отражают намерения в контрактах
классов/интерфейсов. Контракт должен отражать то, что делает компонент его
реализующий. Нужда смотреть реализацию, которую такой код порождает тем, что
скрывает назначение полей, должна отсуствовать.

// AVOID
public interface Something {
    Pair<String, SomethingDatum> doSomething();
}

// PREFER
public interface Something {
    IndexedSomethingDatum doSomething();
}

@Data
class IndexedSomethingDatum {
    private String index;
    private SomethingDatum datum;
}
8. Checkstyle.
1. Берем checkstyle.xml

2. Далее открываем IDE и идем File->Settings->Plugins.

3. Ставим плагин CheckStyle-IDEA

4. Далее File->Settings->Code Style->Java

5. Нажимаем на шестеренку -> Import Scheme -> Checkstyle Configuration



</span>
</p>

</div>
</body>
</html>
